# save_media.py ‚Äî mitmproxy addon
from mitmproxy import http, ctx
import os, re, time, threading, sys
from pathlib import Path
from urllib.parse import urlparse, unquote
from io import BytesIO
from PIL import Image, UnidentifiedImageError
from datetime import datetime
import mimetypes

try:
    import magic
    HAS_MAGIC = True
except ImportError:
    HAS_MAGIC = False
    

# ---------------------------------------------------------------------------
# Path & import setup
# ---------------------------------------------------------------------------
BASE_DIR   = Path(__file__).parent.parent           # project root
CONFIG_DIR = BASE_DIR / "config"
CONFIG_PATH = CONFIG_DIR / "media_proxy_config.yaml"
LOGS_DIR  = BASE_DIR / "logs"
DOMAINS_LOG_PATH = LOGS_DIR / "domains_seen.txt"
LOGS_DIR.mkdir(parents=True, exist_ok=True)

# Ensure project and scripts dirs on sys.path
for p in (BASE_DIR, BASE_DIR / "scripts"):
    if str(p) not in sys.path:
        sys.path.insert(0, str(p))

from tzMCP.config_manager import ConfigManager, Config  # after path tweak

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _load_config() -> Config:
    return ConfigManager(CONFIG_PATH).load_config()


def _log_skip(reason: str):
    """Log a red‚Äëcolored skip reason in mitmproxy console."""
    ctx.log.error(f"‚è≠ {reason}")
    print(f"‚è≠ {reason}", flush=True)

# Maps for MIME to extensions
EXT_MAP = {
    "image/jpeg": ".jpg",
    "image/png": ".png",
    "image/webp": ".webp",
    "image/gif": ".gif",
    "image/svg+xml": ".svg",
    "image/bmp": ".bmp",
    "image/tiff": ".tiff",
    "image/x-icon": ".ico",
    "image/vnd.microsoft.icon": ".ico",
    "video/mp4": ".mp4",
    "video/webm": ".webm",
    "video/quicktime": ".mov",
}

def detect_mime_extension(content: bytes, headers: dict) -> str:
    """Attempt to detect MIME type and map to a file extension."""
    mime = headers.get("content-type", "").lower().split(";")[0].strip()

    if not mime and HAS_MAGIC:
        try:
            mime = magic.from_buffer(content, mime=True)
        except Exception:
            mime = ""

    if not mime or mime == "application/x-empty":
        if content.startswith(b"RIFF") and b"WEBP" in content[8:16]:
            mime = "image/webp"

    return EXT_MAP.get(mime, mimetypes.guess_extension(mime) or ".bin")

class MediaSaver:
    """Addon that saves responses matching config filters and logs skip reasons."""

    def __init__(self):
        self.config: Config = _load_config()
        self._compile_filters()
        ctx.log.info("MediaSaver addon initialized üí°")
        print("MediaSaver addon initialized üí°", flush=True)
        if self.config.auto_reload_config:
            threading.Thread(target=self._watch_config, daemon=True).start()

    # -------------------------------------------------------------------
    # Config handling
    # -------------------------------------------------------------------
    def _watch_config(self):
        last = CONFIG_PATH.stat().st_mtime if CONFIG_PATH.exists() else None
        while True:
            time.sleep(5)
            if CONFIG_PATH.exists():
                m = CONFIG_PATH.stat().st_mtime
                if m != last:
                    self.config = _load_config()
                    self._compile_filters()
                    ctx.log.info("üîÑ MediaSaver config reloaded")
                    print("üîÑ MediaSaver config reloaded", flush=True)
                    last = m

    def _compile_filters(self):
        # Extension regex (allow query params)
        exts = [ext.lstrip('.') for ext in self.config.extensions]
        self.ext_pattern = re.compile(r"\.(" + "|".join(re.escape(e) for e in exts) + r")(?:$|\?)", re.I)
        # Whitelist/Blacklist
        wl = [p for p in self.config.whitelist if p.strip()]
        bl = [p for p in self.config.blacklist if p.strip()]
        self.whitelist_pattern = re.compile("|".join(wl)) if wl else None
        self.blacklist_pattern = re.compile("|".join(bl)) if bl else None
        # Pixel + size
        pd = self.config.filter_pixel_dimensions
        self.pixel_enabled = pd.get("enabled", False)
        self.min_w, self.min_h = pd.get("min_width", 0), pd.get("min_height", 0)
        self.max_w, self.max_h = pd.get("max_width", 1e9), pd.get("max_height", 1e9)
        fs = self.config.filter_file_size
        self.size_enabled = fs.get("enabled", False)
        self.min_bytes, self.max_bytes = fs.get("min_bytes", 0), fs.get("max_bytes", 1e12)
        # Save dir
        self.save_dir = self.config.save_dir
        self.save_dir.mkdir(parents=True, exist_ok=True)

    # -------------------------------------------------------------------
    # mitmproxy hooks
    # -------------------------------------------------------------------
    def response(self, flow: http.HTTPFlow):
        url = flow.request.url
        domain = flow.request.host
        content = flow.response.content
        size = len(content)
        
        # --- MIME TYPE DETECTION ---
        mime = flow.response.headers.get("content-type", "").lower().split(";")[0].strip()
        print(f"üíæ 1 ({mime} mimetype)", flush=True)

        if not mime.startswith("image/"):
            if HAS_MAGIC:
                try:
                    mime = magic.from_buffer(content, mime=True)
                    print(f"üíæ 2 ({mime} mimetype)", flush=True)
                except Exception:
                    mime = ""
            if not mime.startswith("image/"):
                print(f"‚è≠ Skipped {url} (not an image: {mime})", flush=True)
                return

        # --- EXTENSION RESOLUTION ---
        ext = EXT_MAP.get(mime, mimetypes.guess_extension(mime) or ".bin")

        # 1. Extension filter
        if not self.ext_pattern.search(url):
            # Commented out too many files shown that are irrelivant.
            # _log_skip(f"{url} ‚Äì extension not allowed")
            return

        # 2. Domain filters
        if self.whitelist_pattern and not self.whitelist_pattern.search(domain):
            _log_skip(f"{url} - domain not whitelisted")
            return
        if self.blacklist_pattern and self.blacklist_pattern.search(domain):
            _log_skip(f"{url} - domain blacklisted")
            return

        # 3. Size filter
        if self.size_enabled and not (self.min_bytes <= size <= self.max_bytes):
            _log_skip(f"{url} - {size}B not in [{self.min_bytes},{self.max_bytes}]")
            return

        # 4. Pixel filter
        if self.pixel_enabled:
            try:
                img = Image.open(BytesIO(content))
                w, h = img.size
                if not (self.min_w <= w <= self.max_w and self.min_h <= h <= self.max_h):
                    _log_skip(f"{url} - {w}x{h}px not in range")
                    return
            except UnidentifiedImageError:
                _log_skip(f"{url} - not an image for pixel check")
                return

        # 5. Save file
        self.save_dir.mkdir(parents=True, exist_ok=True)
        parsed_path = urlparse(url).path
        fname = unquote(os.path.basename(parsed_path)) or f"untitled_{int(time.time() * 1000)}"
        save_path = self.save_dir / fname
        try:
            with save_path.open('wb') as f:
                f.write(content)
            ctx.log.info(f"üíæ Saved ‚Üí {save_path} ({size}B)")
            print(f"üíæ Saved ‚Üí {save_path} ({size}B)", flush=True)
        except Exception as e:
            ctx.log.error(f"Saved failed: {e}")
            print(f"Save failed: {e}", flush=True)
            return

        # 6. Log domain
        if self.config.log_seen_domains:
            with DOMAINS_LOG_PATH.open("a", encoding="utf-8") as domf:
                domf.write(domain + "\n")


addons = [MediaSaver()]
